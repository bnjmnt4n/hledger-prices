package main

import (
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	"reflect"
	"strconv"
	"strings"
	"time"
)

var (
	alphavantageKey = flag.String("alpha-vantage-key", "", "Alpha Vantage API key")
	baseCurrency    = flag.String("base-currency", "USD", "Base currency")
	stocks          = flag.String("stocks", "", "Stocks to obtain data for")
	currencies      = flag.String("currencies", "", "Currencies to obtain data for")
	delay           = flag.Int("delay", 0, "Number of seconds to delay to add between API requests")
)

type currencyExchangeRate struct {
	FromCurrency string    `json:"1. From_Currency Code"`
	ToCurrency   string    `json:"3. To_Currency Code"`
	ExchangeRate float64   `json:"5. Exchange Rate"`
	Date         time.Time `json:"6. Last Refreshed"`
}

type stock struct {
	Symbol string    `json:"01. symbol"`
	Price  float64   `json:"05. price"`
	Date   time.Time `json:"07. latest trading day"`
}

func (currency *currencyExchangeRate) UnmarshalJSON(b []byte) error {
	err := UnmarshalJsonWithCustomDate(b, currency, "2006-01-02 15:04:05")
	if err != nil {
		return err
	}

	return nil
}

func (stock *stock) UnmarshalJSON(b []byte) error {
	err := UnmarshalJsonWithCustomDate(b, stock, "2006-01-02")
	if err != nil {
		return err
	}

	return nil
}

// Unmarshal JSON with custom parsing to create `time.Time` fields.
func UnmarshalJsonWithCustomDate[T any](b []byte, struct_ptr *T, dateLayout string) error {
	var unmarshalledJson map[string]string
	err := json.Unmarshal(b, &unmarshalledJson)
	if err != nil {
		return err
	}

	struct_value := reflect.ValueOf(struct_ptr).Elem()
	struct_type := reflect.TypeOf(*struct_ptr)
	num_fields := struct_type.NumField()

	for i := 0; i < num_fields; i++ {
		field := struct_type.Field(i)
		field_name := field.Name
		json_field_name := field.Tag.Get("json")

		if field_value, ok := unmarshalledJson[json_field_name]; ok {
			st_field := struct_value.FieldByName(field_name)

			if st_field.Kind() == reflect.String {
				st_field.SetString(field_value)
			} else if st_field.Kind() == reflect.Float64 {
				fl, err := strconv.ParseFloat(field_value, 64)
				if err != nil {
					return err
				}

				st_field.SetFloat(fl)
			} else if st_field.Type() == reflect.TypeOf(time.Time{}) {
				date, err := time.Parse(dateLayout, field_value)
				if err != nil {
					return err
				}

				st_field.Set(reflect.ValueOf(date))
			}
		}
	}

	return nil
}

func main() {
	flag.Parse()

	fmt.Println("; Generated by https://github.com/bnjmnt4n/hledger-prices on", time.Now().Format("2006/01/02"))

	errors := make([]error, 0)

	// Get currency exchange rates.
	currencies_str := strings.TrimSpace(*currencies)
	if currencies_str != "" {
		fmt.Println("; Currencies")

		currencies_chan, errors_chan := make(chan currencyExchangeRate), make(chan error)
		currency_symbols := strings.Split(currencies_str, ",")
		go getCurrencies(currency_symbols, currencies_chan, errors_chan)

		for i := 0; i < len(currency_symbols); i++ {
			select {
			case exchange_rate := <-currencies_chan:
				_, err := fmt.Printf("P %s %s %s %f", exchange_rate.Date.Format("2006/01/02"), exchange_rate.FromCurrency, exchange_rate.ToCurrency, exchange_rate.ExchangeRate)
				fmt.Println("")
				if err != nil {
					// TODO: handle errors.
				}
			case err := <-errors_chan:
				errors = append(errors, err)
			}
		}
	}

	// Get stock prices.
	stock_symbols_str := strings.TrimSpace(*stocks)
	if stock_symbols_str != "" {
		fmt.Println("; Stocks")

		stocks_chan, errors_chan := make(chan stock), make(chan error)
		stock_symbols := strings.Split(stock_symbols_str, ",")
		go getStockPrices(stock_symbols, stocks_chan, errors_chan)

		for i := 0; i < len(stock_symbols); i++ {
			select {
			case stock := <-stocks_chan:
				_, err := fmt.Printf("P %s %s %s %f", stock.Date.Format("2006/01/02"), stock.Symbol, stock.Currency, stock.Price)
				fmt.Println("")
				if err != nil {
					// TODO: handle errors.
				}
			case err := <-errors_chan:
				errors = append(errors, err)
			}
		}
	}

	// TODO: print to STDERR?
	for _, err := range errors {
		fmt.Println(err)
	}
}

var isFirstRequest bool = true

func getAlphavantageData(url string, output any) error {
	if !isFirstRequest {
		time.Sleep(time.Second * time.Duration(*delay))
	}

	resp, err := http.Get(url)
	isFirstRequest = false
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		bytes, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			return fmt.Errorf("Status code %d: Failed to read body: %w", resp.StatusCode, err)
		}

		return fmt.Errorf("Status code %d: %s", resp.StatusCode, string(bytes))
	}

	var data map[string]any
	err = json.NewDecoder(resp.Body).Decode(&data)
	if err != nil {
		return err
	}

	// API returns error message in JSON field `Note`.
	if error_note, ok := data["Note"]; ok {
		return fmt.Errorf("Error: %s", error_note)
	}

	// JSON returned only contains a single item with an inner object.
	for _, data := range data {
		if data, ok := data.(map[string]any); ok {
			json_bytes, err := json.Marshal(data)
			if err != nil {
				return err
			}

			err = json.Unmarshal(json_bytes, output)
			if err != nil {
				return err
			}

			return nil
		} else {
			return errors.New("Could not convert data into output type")
		}
	}

	return errors.New("Response had no data")
}

func getCurrencies(currencies []string, currencies_chan chan<- currencyExchangeRate, errors_chan chan<- error) {
	for _, currency_sym := range currencies {
		url := fmt.Sprintf("https://www.alphavantage.co/query?function=CURRENCY_EXCHANGE_RATE&from_currency=%s&to_currency=%s&apikey=%s", currency_sym, *baseCurrency, *alphavantageKey)
		exchange_rate := new(currencyExchangeRate)
		err := getAlphavantageData(url, exchange_rate)

		if err != nil {
			errors_chan <- fmt.Errorf("Failed to get currency %s: %w", currency_sym, err)
		} else {
			currencies_chan <- *exchange_rate
		}
	}

	close(currencies_chan)
	close(errors_chan)
}

func getStockPrices(stock_symbols []string, stocks_chan chan<- stock, errors_chan chan<- error) {
	for _, stock_sym := range stock_symbols {
		url := fmt.Sprintf("https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=%s&apikey=%s", stock_sym, *alphavantageKey)
		stock := new(stock)
		err := getAlphavantageData(url, stock)

		if err != nil {
			errors_chan <- fmt.Errorf("Failed to get stock price for %s: %w", stock_sym, err)
		} else {
			stocks_chan <- *stock
		}
	}

	close(stocks_chan)
	close(errors_chan)
}
