package main

import (
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	"reflect"
	"strconv"
	"strings"
	"time"
)

var (
	alphavantageKey = flag.String("alphavantage-key", "", "API key for Alphavantage")
	baseCurrency    = flag.String("base-currency", "SGD", "Base currency")
	stocks          = flag.String("stocks", "", "Stocks to obtain data for")
	currencies      = flag.String("currencies", "USD", "Currencies to obtain data for")
	delay           = flag.Int("delay", 15, "Number of seconds to delay between requests")
)

type currencyExchangeRate struct {
	FromCurrency string    `json:"1. From_Currency Code"`
	ToCurrency   string    `json:"3. To_Currency Code"`
	ExchangeRate float64   `json:"5. Exchange Rate"`
	Date         time.Time `json:"6. Last Refreshed"`
}

type stock struct {
	Symbol string    `json:"01. symbol"`
	Price  float64   `json:"05. price"`
	Date   time.Time `json:"07. latest trading day"`
}

func (currency *currencyExchangeRate) UnmarshalJSON(b []byte) error {
	var unmarshalledJson map[string]string
	err := json.Unmarshal(b, &unmarshalledJson)
	if err != nil {
		return err
	}

	struct_value := reflect.ValueOf(currency).Elem()
	struct_type := reflect.TypeOf(*currency)
	num_fields := struct_type.NumField()

	for i := 0; i < num_fields; i++ {
		field := struct_type.Field(i)
		field_name := field.Name
		json_field_name := field.Tag.Get("json")

		if field_value, ok := unmarshalledJson[json_field_name]; ok {
			st_field := struct_value.FieldByName(field_name)

			if st_field.Kind() == reflect.String {
				st_field.SetString(field_value)
			} else if st_field.Kind() == reflect.Float64 {
				fl, err := strconv.ParseFloat(field_value, 64)
				if err != nil {
					return err
				}

				st_field.SetFloat(fl)
			} else if st_field.Type() == reflect.TypeOf(time.Time{}) {
				date, err := time.Parse("2006-01-02 15:04:05", field_value)
				if err != nil {
					return err
				}

				st_field.Set(reflect.ValueOf(date))
			}
		}
	}

	return nil
}

func (stock *stock) UnmarshalJSON(b []byte) error {
	var unmarshalledJson map[string]string
	err := json.Unmarshal(b, &unmarshalledJson)
	if err != nil {
		return err
	}

	struct_value := reflect.ValueOf(stock).Elem()
	struct_type := reflect.TypeOf(*stock)
	num_fields := struct_type.NumField()

	for i := 0; i < num_fields; i++ {
		field := struct_type.Field(i)
		field_name := field.Name
		json_field_name := field.Tag.Get("json")

		if field_value, ok := unmarshalledJson[json_field_name]; ok {
			st_field := struct_value.FieldByName(field_name)

			if st_field.Kind() == reflect.String {
				st_field.SetString(field_value)
			} else if st_field.Kind() == reflect.Float64 {
				fl, err := strconv.ParseFloat(field_value, 64)
				if err != nil {
					return err
				}

				st_field.SetFloat(fl)
			} else if st_field.Type() == reflect.TypeOf(time.Time{}) {
				date, err := time.Parse("2006-01-02", field_value)
				if err != nil {
					return err
				}

				st_field.Set(reflect.ValueOf(date))
			}
		}
	}

	return nil
}

func main() {
	flag.Parse()

	fmt.Println("; Generated by https://github.com/bnjmnt4n/hledger-prices on", time.Now().Format("2006/01/02"))

	currencies_str := strings.TrimSpace(*currencies)
	if currencies_str != "" {
		fmt.Println("; Currencies")

		currency_symbols := strings.Split(currencies_str, ",")
		currencies, err := getCurrencies(currency_symbols)
		if err != nil {
			fmt.Println(err)
		}

		for _, item := range currencies {
			_, err := fmt.Printf("P %s %s %s %f", item.Date.Format("2006/01/02"), item.FromCurrency, item.ToCurrency, item.ExchangeRate)
			fmt.Println("")
			if err != nil {
				// TODO: handle errors.
			}
		}
	}


	stock_symbols_str := strings.TrimSpace(*stocks)
	if stock_symbols_str != "" {
		fmt.Println("; Stocks")

		stock_symbols := strings.Split(stock_symbols_str, ",")
		stocks, err := getStockPrices(stock_symbols)
		if err != nil {
			fmt.Println(err)
		}

		for _, item := range stocks {
			_, err := fmt.Printf("P %s %s USD %f", item.Date.Format("2006/01/02"), item.Symbol, item.Price)
			fmt.Println("")
			if err != nil {
				// TODO: handle errors.
			}
		}
	}
}

var isFirstRequest bool = true

func getAlphavantageData(url string, output any) error {
	if !isFirstRequest {
		time.Sleep(time.Second * time.Duration(*delay))
	}

	resp, err := http.Get(url)
	isFirstRequest = false
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		bytes, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			return fmt.Errorf("Status code %d: Failed to read body: %w", resp.StatusCode, err)
		}

		return fmt.Errorf("Status code %d: %s", resp.StatusCode, string(bytes))
	}

	var data map[string]any
	err = json.NewDecoder(resp.Body).Decode(&data)
	if err != nil {
		return err
	}

	// API returns error message in JSON field `Note`.
	if error_note, ok := data["Note"]; ok {
		return fmt.Errorf("Error: %s", error_note)
	}

	// JSON returned only contains a single item with an inner object.
	for _, data := range data {
		if data, ok := data.(map[string]any); ok {
			json_bytes, err := json.Marshal(data)
			if err != nil {
				return err
			}

			err = json.Unmarshal(json_bytes, output)
			if err != nil {
				return err
			}

			return nil
		} else {
			return errors.New("Could not convert data into output type")
		}
	}

	return errors.New("Response had no data")
}

func getCurrencies(currencies []string) ([]currencyExchangeRate, error) {
	currency_rates := make([]currencyExchangeRate, 0, len(currencies))
	for _, currency := range currencies {
		url := fmt.Sprintf("https://www.alphavantage.co/query?function=CURRENCY_EXCHANGE_RATE&from_currency=%s&to_currency=%s&apikey=%s", currency, *baseCurrency, *alphavantageKey)
		data := new(currencyExchangeRate)
		err := getAlphavantageData(url, data)
		if err != nil {
			return nil, fmt.Errorf("Failed to get currency %s: %w", currency, err)
		}

		currency_rates = append(currency_rates, *data)
	}

	return currency_rates, nil
}

func getStockPrices(stock_symbols []string) ([]stock, error) {
	stocks := make([]stock, 0, len(stock_symbols))

	for _, stock_sym := range stock_symbols {
		url := fmt.Sprintf("https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=%s&apikey=%s", stock_sym, *alphavantageKey)
		data := new(stock)
		err := getAlphavantageData(url, data)
		if err != nil {
			return nil, fmt.Errorf("Failed to get stock price for %s: %w", stock_sym, err)
		}

		stocks = append(stocks, *data)
	}

	return stocks, nil
}
